% wf_retinotopy: run after loading sparse noise experiment with
% ap.load_experiment

% Use raw blue signal (best SNR)
surround_window = [0.3,0.5]; % 6s = [0.3,0.5], deconv = [0.05,0.15]
framerate = 1./nanmean(diff(wf_times));
surround_samplerate = 1/(framerate*1);
surround_time = surround_window(1):surround_samplerate:surround_window(2);
response_n = nan(n_y_squares,n_x_squares);
response_grid = cell(n_y_squares,n_x_squares);
for px_y = 1:n_y_squares
    for px_x = 1:n_x_squares

        align_times = ...
            stim_times(find( ...
            (noise_locations(px_y,px_x,1:end-1) == 128 & ...
            noise_locations(px_y,px_x,2:end) == 255) | ...
            (noise_locations(px_y,px_x,1:end-1) == 128 & ...
            noise_locations(px_y,px_x,2:end) == 0))+1);

        response_n(px_y,px_x) = length(align_times);

        % Don't use times that fall outside of imaging
        align_times(align_times + surround_time(1) < wf_times(2) | ...
            align_times + surround_time(2) > wf_times(end)) = [];

        % Get stim-aligned responses, 2 choices:

        % 1) Interpolate times (slow - but supersamples so better)
        %         align_surround_times = bsxfun(@plus, align_times, surround_time);
        %         peri_stim_v = permute(mean(interp1(frame_t,fV',align_surround_times),1),[3,2,1]);

        % 2) Use closest frames to times (much faster - not different)
        align_surround_times = align_times + surround_time;
        frame_edges = [wf_times;wf_times(end)+1/framerate];
        align_frames = discretize(align_surround_times,frame_edges);

        % Get stim-aligned baseline (at stim onset)
        align_baseline_times = align_times;
        align_frames_baseline = discretize(align_baseline_times,frame_edges);

        % Don't use NaN frames (delete, dirty)
        nan_stim = any(isnan(align_frames),2) | isnan(align_frames_baseline);
        align_frames(nan_stim,:) = [];
        align_frames_baseline(nan_stim,:) = [];

        % Define the peri-stim V's as subtracting first frame (baseline)
        peri_stim_v = ...
            reshape(wf_V_raw{1}(:,align_frames)',size(align_frames,1),size(align_frames,2),[]) - ...
            nanmean(reshape(wf_V_raw{1}(:,align_frames_baseline)',size(align_frames_baseline,1),size(align_frames_baseline,2),[]),2);

        mean_peri_stim_v = permute(mean(peri_stim_v,2),[3,1,2]);

        % Store V's
        response_grid{px_y,px_x} = mean_peri_stim_v;

    end
end

% Get position preference for every pixel
U_downsample_factor = 1; %2 if max method
screen_resize_scale = 1; %3 if max method
filter_sigma = (screen_resize_scale*2);

% Downsample U
[Uy,Ux,nSV] = size(wf_U);
Ud = imresize(wf_U,1/U_downsample_factor,'bilinear');

% Convert V responses to pixel responses
use_svs = 1:min(2000,size(Ud,3)); % can de-noise if reduced
n_boot = 10;

response_mean_bootstrap = cellfun(@(x) bootstrp(n_boot,@mean,x')',response_grid,'uni',false);

%%%%%%% Get retinotopy (for each bootstrap)
vfs_boot = nan(size(Ud,1),size(Ud,2),n_boot);
for curr_boot = 1:n_boot

    response_mean = cell2mat(cellfun(@(x) x(:,curr_boot),response_mean_bootstrap(:),'uni',false)');
    stim_im_px = reshape(permute(plab.wf.svd2px(Ud(:,:,use_svs), ...
        response_mean(use_svs,:)),[3,1,2]),n_y_squares,n_x_squares,[]);
    gauss_filt = fspecial('gaussian',[n_y_squares,n_x_squares],filter_sigma);
    stim_im_smoothed = imfilter(imresize(stim_im_px,screen_resize_scale,'bilinear'),gauss_filt);

    %     % (for troubleshooting: scroll through px stim responses)
    %     AP_imscroll(reshape(permute(stim_im_px,[3,1,2]),size(Ud,1),size(Ud,2),[]));
    %     axis image;clim(max(abs(clim)).*[-1,1]);colormap(AP_colormap('BWR'));

    % Get center-of-mass screen response for each widefield pixel
    [yy,xx] = ndgrid(1:size(stim_im_smoothed,1),1:size(stim_im_smoothed,2));
    m_xr = reshape(sum(sum(bsxfun(@times,stim_im_smoothed.^2,xx),1),2)./sum(sum(stim_im_smoothed.^2,1),2),size(Ud,1),size(Ud,2));
    m_yr = reshape(sum(sum(bsxfun(@times,stim_im_smoothed.^2,yy),1),2)./sum(sum(stim_im_smoothed.^2,1),2),size(Ud,1),size(Ud,2));

    % Calculate and plot sign map (dot product between horz & vert gradient)

    % 1) get gradient direction
    [~,Vdir] = imgradient(imgaussfilt(m_yr,1));
    [~,Hdir] = imgradient(imgaussfilt(m_xr,1));

    % 3) get sin(difference in direction) if retinotopic, H/V should be
    % orthogonal, so the closer the orthogonal the better (and get sign)
    angle_diff = sind(Vdir-Hdir);
    angle_diff(isnan(angle_diff)) = 0;

    vfs_boot(:,:,curr_boot) = angle_diff;
end

vfs = imgaussfilt(nanmean(vfs_boot,3),2);

figure;
imagesc(vfs)
axis image off;
colormap(AP_colormap('BWR'));
title(sprintf('%s, %s',animal,rec_day));


%% Align retinotopy to master retinotopy
% Plot CCF areas and coordinates aligned to master retinotopy

% Align retinotopy to CCF 
vfs_ccf_aligned = ap.align_widefield(vfs,[],[],'new_animal');
close(gcf);

figure;
imagesc(vfs)
axis image off;
colormap(AP_colormap('BWR'))


% Load master VFS
master_vfs_fn = ['lilrig_master_vfs.mat'];
load(master_vfs_fn);
master_align = master_vfs;

% Align animal image to master image
ref_size = size(master_align);

[optimizer, metric] = imregconfig('monomodal');
optimizer = registration.optimizer.OnePlusOneEvolutionary();
optimizer.MaximumIterations = 200;
optimizer.GrowthFactor = 1+1e-6;
optimizer.InitialRadius = 1e-4;

tformEstimate_affine = imregtform(vfs_boot_mean,master_align,'affine',optimizer,metric);
vfs_aligned = imwarp(vfs_boot_mean,tformEstimate_affine,'Outputview',imref2d(ref_size));
avg_im_aligned = imwarp(avg_im,tformEstimate_affine,'Outputview',imref2d(ref_size));

% Plot alignment
figure;
subplot(1,2,1);
imshowpair(master_align,vfs_boot_mean);
title('Unaligned VFS');
subplot(1,2,2);
imshowpair(master_align,vfs_aligned);
title('Aligned VFS');

% Plot average image with CCF overlay
figure;
overlay_color = 'b';

ax1 = axes('units','normalized','Position',[0,0,0.5,1]);
ax2 = axes('units','normalized','Position',[0,0,0.5,1]);
h1 = imagesc(ax1,avg_im_aligned);
colormap(ax1,gray);
caxis(ax1,[0 prctile(avg_im(:),98)]);
h2 = imagesc(ax2,vfs_aligned);
axes(ax1); hold on; axis equal off;
axes(ax2); hold on; axis equal off;
colormap(ax2,colormap_BlueWhiteRed);
caxis([-1,1]);
set(h2,'AlphaData',mat2gray(abs(vfs_aligned))*0.4);
colormap(ax1,gray);
title(ax1,'VFS/CCF overlay');
% (load and plot aligned CCF boundaries)
hold on;
load(['lilrig_cortical_area_boundaries_aligned.mat']);
h = cellfun(@(areas) cellfun(@(outline) ...
    plot(ax2,outline(:,2),outline(:,1),'color',overlay_color),areas,'uni',false), ...
    cortical_area_boundaries_aligned,'uni',false);

% Plot average image with grid overlay
subplot(1,2,2);
imagesc(avg_im_aligned);
caxis([0 prctile(avg_im(:),98)]);
colormap(gca,'gray');
axis image off
title('0.5mm grid overlay');
% (plot grid)
hold on
um2pixel = 20.6;
bregma = [540,0,570] + 0.5;
ccf_tform_fn = ['lilrig_ccf_tform.mat'];
load(ccf_tform_fn);
bregma_resize = bregma*(10/um2pixel);
bregma_align = [bregma_resize([3,1]),1]*ccf_tform.T;
bregma_offset_x = bregma_align(1);
bregma_offset_y = bregma_align(2);



